<TeXmacs|2.1>

<style|generic>

<\body>
  <chapter|Limit>

  <section|Cone Functor and Limit>

  In this section, we discuss an important application of universal element
  or representation: limit. We are to show that limit is a representation of
  a functor that generates objects called cones.

  Now, the problem turns to be why cones are important. Because many
  important mathematical concepts are turn out to be cones. Remember in
  chapter <reference|chapter: Category, Functor, and Natural Transformation>,
  we have embedded some concepts in the framework of category theory, such as
  supremum and infimum, Cartesian product and adjoint union. These concepts,
  once re-written by arrows, looks weird. You may wonder where these weird
  stuffs come from. In fact, they come from limit.

  To define limit, we have to first introduce diagram, and then cone.

  <subsection|Diagram as a part of category is a functor>

  When we were discussing category, functor, and natural transformation, we
  used the metaphor that a category is a collection of diagrams. Well, what
  is a diagram precisely? Naturally, a diagram is a part of a category, say
  <math|<math-ss|C>>. By part, we indicates two aspects: the set of dots
  (objects) in a diagram is a subset of the <math|ob<rsub|<math-ss|C>>>, and
  the set of arrows (morphisms) between dots <math|X> and <math|Y> is a
  subset of the <math|<math-ss|C><around*|(|X,Y|)>>.

  Remind that, in category theory, everything should be described by arrows.
  So, how to describe a diagram by arrows?

  Let us consider a simpler case: set theory, where a part simply means a
  finite subset. Such a subset of set <math|S> is written as
  <math|A\<assign\><around*|{|x<rsub|1>,\<ldots\>,x<rsub|n>|}>>, where
  <math|x<rsub|i>\<in\>S>. A set corresponds to a discrete category, and a
  function between sets to a functor between discrete categories. (A discrete
  category <math|<math-ss|C>> is that with
  <math|<math-ss|C><around*|(|X,X|)>=<around*|{|1<rsub|X>|}>> and
  <math|<math-ss|C><around*|(|X,Y|)>=\<varnothing\>> for each
  <math|X,Y\<in\><math-ss|C>>.) So, we are to describe <math|A> by function.
  A natural one is <math|f:I\<rightarrow\>S>, where
  <math|I\<assign\><around*|{|1,\<ldots\>,n|}>> as an \Pindexing set\Q, and
  <math|f<around*|(|i|)>\<assign\>x<rsub|i>>.

  Back to category theory, the indexing set analyzes to a small category
  <math|<math-ss|I>> called indexing category, and the function <math|f>
  analyzes to functor <math|F:<math-ss|I>\<rightarrow\><math-ss|C>>. Indexing
  category is used for filtering the objects and morphisms in
  <math|<math-ss|C>>, so that the image is a part of <math|<math-ss|C>>, that
  is, a diagram. We summarize the previous analysis as follow.

  <\definition>
    [Diagram] Let <math|<math-ss|I>> a small category and <math|<math-ss|C>>
    a category. An <math|<math-ss|I>>-shaped <with|font-series|bold|diagram>
    in <math|<math-ss|C>> is a functor <math|F:<math-ss|I>\<rightarrow\><math-ss|C>>.
    It is small or locally small if <math|<math-ss|C>> is small or locally
    small respectively.
  </definition>

  <subsection|Cone irradiates diagram>

  With diagram declared, we come to cone. A light cone generated by a table
  lamp irradiates the table. The table lamp is an object, and the table is a
  diagram. So, a cone irradiates a diagram.

  But, how can we describe the relation between an object and a diagram,
  which is a functor? To make this possible, we have to make the most boring
  definition so far: the constant functor. Constant functor converts an
  object to a functor.

  <\definition>
    [Constant Functor] Let <math|<math-ss|C>> and <math|<math-ss|D>>
    categories. For each <math|X\<in\><math-ss|D>>, the
    <with|font-series|bold|constant functor> of <math|X>,
    <math|Const<rsub|X>:<math-ss|C>\<rightarrow\><math-ss|D>>, is defined by

    <\itemize>
      <item>for each <math|A\<in\><math-ss|C>>,
      <math|Const<rsub|X><around*|(|A|)>=X>, and

      <item>for each <math|f:A\<rightarrow\>B>,
      <math|Const<rsub|X><around*|(|f|)>=1<rsub|X>>.
    </itemize>
  </definition>

  With this trivial definition, we can describe the relation between an
  object, or its constant functor, and a diagram.

  <\definition>
    [Cone] For each diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and
    each object <math|X\<in\><math-ss|C>>, a cone from <math|X> to <math|D>
    is a natural transformation <math|\<lambda\>:Const<rsub|X>\<rightarrow\>D>.
  </definition>

  <big-figure|<image|figures/cone.png|0.75par|||>|<label|figure: Cone> The
  left hand side indicates the indexing category <math|<math-ss|I>>. And the
  right hand side indicates the cone from <math|X> to <math|D>. The green
  arrows are for functor <math|Const<rsub|X>>, and the red ones for functor
  <math|D>, wherein maps on morphisms are not shown. As usual, identities are
  hidden. Since the <math|\<lambda\>> is a natural transformation, the right
  hand side commutes.>

  It should be noted that, in figure <reference|figure: Cone>, some morphism
  are redundant. For instance, <math|\<lambda\><rsub|A>=D<around*|(|h|)>\<circ\>\<lambda\><rsub|C>>
  and <math|\<lambda\><rsub|B>=D<around*|(|f|)>\<circ\>\<lambda\><rsub|A>=D<around*|(|f|)>\<circ\>D<around*|(|h|)>\<circ\>\<lambda\><rsub|C>>.
  So, when <math|\<lambda\><rsub|C>> has been drawn,
  <math|\<lambda\><rsub|A>> and <math|\<lambda\><rsub|B>> are omitable,
  usually absent in the diagram.

  <subsection|Cone functor generates cones>

  Notice a cone consists two parts: the diagram and the summit object. Given
  a diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and a summit object
  <math|X\<in\><math-ss|C>>, the natural transformation
  <math|\<lambda\>:Const<rsub|X>\<rightarrow\>D> is not unique. There can be
  a plenty of such natural transformations, depending on how many morphisms
  there are between objects in <math|<math-ss|C>>. We can collect these
  natural transformations together as a set, <math|Cone<around*|(|X,D|)>>.

  For the set of morphisms from <math|X> to <math|Y>,
  <math|<math-ss|C><around*|(|X,Y|)>>, we constructed a functor
  <math|<math-ss|C><around*|(|-,Y|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>.
  The same goes for <math|Cone<around*|(|X,D|)>>. We can construct a functor
  <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>.
  Naturally, it maps <math|X\<in\><math-ss|C>> to
  <math|Cone<around*|(|X,D|)>>, but what about the morphism, say
  <math|f:Y\<rightarrow\>X>? Consider a cone
  <math|\<lambda\>\<in\>Cone<around*|(|X,D|)>>, which is a natural
  transformation from <math|Const<rsub|X>:<math-ss|I>\<rightarrow\><math-ss|C>>
  to <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>. A component
  <math|\<lambda\><rsub|A>:X\<rightarrow\>D<around*|(|A|)>>. To construct a
  morphism <math|Y\<rightarrow\>D<around*|(|A|)>> out of
  <math|\<lambda\><rsub|A>> and <math|f>, the only possibility is
  <math|Y<above|\<rightarrow\>|f>X<above|\<rightarrow\>|\<lambda\><rsub|A>>D<around*|(|A|)>>,
  that is <math|\<lambda\><rsub|A>\<circ\>f>.

  <\definition>
    [Cone Functor] For each diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>,
    the <with|font-series|bold|cone functor>
    <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>
    is defined by

    <\itemize>
      <item>for each <math|X\<in\><math-ss|C>>, mapping <math|X> to
      <math|Cone<around*|(|X,D|)>>, the set of all cones from <math|X> to
      <math|D>, and

      <item>for each <math|f:Y\<rightarrow\>X>, mapping <math|f> to function
      <math|f<rsup|\<ast\>>:Cone<around*|(|X,D|)>\<rightarrow\>Cone<around*|(|Y,D|)>>
      defined by <math|f<rsup|\<ast\>><around*|(|\<lambda\><rsub|A>|)>=\<lambda\><rsub|A>\<circ\>f>
      for each component <math|\<lambda\><rsub|A>>. (See also figure
      <reference|figure: Cone Functor>.)
    </itemize>
  </definition>

  <big-figure|<image|figures/cone-1.png|0.55par|||>|<label|figure: Cone
  Functor> Indicates the map on <math|f>. As an instance, the indexing
  category <math|<math-ss|I>> is simply <math|A<above|\<rightarrow\>|g>B>.>

  <subsection|Limit is the representation of cone functor>

  As discussed in section <reference|section: Universal Element>, for a
  locally small category <math|<math-ss|C>>, a functor
  <math|F:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>> can be represented
  by an object in <math|<math-ss|C>>, if universal element exists. Given a
  diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> where
  <math|<math-ss|C>> is locally small (or say, a locally small diagram), a
  cone functor <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>
  thus can be represented by an object in <math|<math-ss|C>>, which we call
  the limit of <math|D>, if universal cone exists.

  Let us restate the universal element for cone functor, which is the
  universal cone. We copy definition <reference|definition: Universal
  Element> to here, with some replacement for cone functor.

  <\definition>
    [Universal Cone] For a locally small diagram
    <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>, a
    <with|font-series|bold|universal cone> is a pair
    <math|><math|<around*|(|lim<rsub|<math-ss|I>>D,e|)>> where <math|lim
    D\<in\><math-ss|C>> and <math|e\<in\>Cone<around*|(|lim<rsub|<math-ss|I>>D,D|)>>
    such that for each <math|X\<in\><math-ss|C>> and
    <math|\<lambda\>\<in\>Cone<around*|(|X,D|)>>, there is a unique morphism
    <math|f:X\<rightarrow\>lim<rsub|<math-ss|I>>D> such that
    <math|\<lambda\>=f<rsup|\<ast\>><around*|(|e|)>>. The
    <math|lim<rsub|<math-ss|I>>D> is called the <with|font-series|bold|limit>
    of <math|D>. (See also figure <reference|figure: Limit>.)
  </definition>

  <big-figure|<image|figures/limit.png|0.5par|||>|<label|figure: Limit>
  Indicates the limit. The dash arrow is for implication. As an instance, the
  indexing category <math|<math-ss|I>> is simply
  <math|A<above|\<rightarrow\>|g>B>.>

  As figure <reference|figure: Limit> indicates, the limit is the lowest
  object towards (the image of) the diagram. So, a limit is the closest
  object to the diagram, thus literally a limit.

  The dual limit is colimit, by simply exchanging domain and codomain in
  limit. As figure <reference|figure: Colimit> shows.

  \ <big-figure|<image|figures/colimit.png|0.5par|||>|<label|figure: Colimit>
  Indicates the colimit. The dash arrow is for implication. As an instance,
  the indexing category <math|<math-ss|I>> is simply
  <math|A<above|\<rightarrow\>|g>B>.>

  Since representation of a functor, if exists, is unique up to isomorphism,
  the limit and colimit, which are representation of the cone and cocone
  functor respectively, are unique up to isomorphism.

  <\theorem>
    [Limit (Colimit) is Unique] The limit (colimit) of a locally small
    diagram is unique up to isomorphism.s
  </theorem>

  <subsection|Infimum is a limit on poset <math|\<bbb-R\>>>

  In section <reference|section: Supremum and infimum are dual>, we roughly
  showed what infimum would be like in the framework of category theory.
  Here, we make it more precise. Recalling the definition of poset (see
  definition <reference|definition: Poset>), the field <math|\<bbb-R\>> forms
  a poset by preorder <math|\<leqslant\>>. So, it forms a poset category
  <math|<math-ss|Poset>>, with object a real number and morphism
  <math|x\<rightarrow\>y> if <math|x\<leqslant\>y>. Consider an indexing
  category <math|<math-ss|I>> as the poset
  <math|<around*|(|A,\<leqslant\>|)>> where <math|A\<subset\>\<bbb-R\>>.
  Diagram <math|D:<math-ss|I>\<rightarrow\>\<bbb-R\>> is defined by
  <math|D<around*|(|x|)>\<assign\>x> for each <math|x\<in\>\<bbb-R\>>. So,
  <math|lim<rsub|<math-ss|I>>D> has the property that, for each
  <math|x\<in\>\<bbb-R\>> and <math|a\<in\>A>, if
  <math|x\<leqslant\>D<around*|(|a|)>>, then
  <math|x\<leqslant\>lim<rsub|<math-ss|I>>D\<leqslant\>D<around*|(|a|)>>.
  This means <math|lim<rsub|<math-ss|I>>D> is the infimum of the set
  <math|A>. So, infimum is a universal cone, or a limit, on poset category.

  Since limit, or generally representation, is unique up to isomorphism,
  infimum and supremum of a subset of <math|\<bbb-R\>> is unique. (Recall
  that the only isomorphism in poset <math|\<bbb-R\>> is
  <math|x\<leqslant\>x> for each <math|x\<in\>\<bbb-R\>>.)

  The same goes for its dual, supremum. If we flip the arrows in the
  definitions of limit, we get the dual, colimit . So, directly, we find
  supremum is the colimit on <math|<math-ss|Poset>>.

  <subsection|Product is a limit with discrete indexing
  category><label|section: Product is a limit with discrete indexing
  category>

  In section <reference|section: Arrows generalize concepts and theorems from
  one area to every area in mathematics>, we showed what Cartesian product
  would be like in the framework of category theory. Let <math|<math-ss|C>> a
  category. For any <math|A,B\<in\><math-ss|C>>, the product of <math|A> and
  <math|B> is another object <math|C\<in\><math-ss|C>> together with two
  morphisms <math|\<alpha\>:C\<rightarrow\>A> and
  <math|\<beta\>:C\<rightarrow\>B> such that, for any
  <math|C<rprime|'>\<in\><math-ss|C>>, any
  <math|\<alpha\><rprime|'>:C<rprime|'>\<rightarrow\>A> and
  <math|\<beta\><rprime|'>:C<rprime|'>\<rightarrow\>B>, there exists a unique
  morphism <math|\<gamma\>:C<rprime|'>\<rightarrow\>C> so that
  <math|\<alpha\><rprime|'>=\<alpha\>\<circ\>\<gamma\>> and
  <math|\<beta\><rprime|'>=\<beta\>\<circ\>\<gamma\>>. If we convert this
  statement to commutative diagram (figure <reference|figure: Product is
  Limit>), then it is apparent that product is a limit, in which the discrete
  category with two elements is the indexing category.

  <big-figure|<image|figures/limit-1.png|0.75par|||>|<label|figure: Product
  is Limit> Indicates that product is a limit. The left hand side is the
  indexing category. There is no morphism (except the hidden identities)
  since it is a discrete category. The name of the object is irrelevant, so
  the two objects are shown as dots. The right hand side is the commutative
  diagram for the definition of product. The green arrows is for the constant
  functor, and red arrows for the diagram functor.>

  Again, since representation of a functor is unique up to isomorphism. The
  product is unique up to isomorphism. Recall that we have proved the
  uniqueness before. Now, the proof is apparent on its own.

  The same goes for coproduct (definition <reference|definition: Coproduct of
  Two Objects>).

  <subsection|Example: product is preserved by adjoint functors>

  In section <reference|section: Adjoint functors preserve representations of
  presheaves and copresheaves>, we showed that adjoint functors preserve
  representations. Figure <reference|figure: Adjoint functors preserve
  product> illustrates explicitly how the adjoint functors <math|F\<dashv\>G>
  preserve the product <math|<around*|(|A\<times\>B,\<alpha\>,\<beta\>|)>>.

  <big-figure|<image|figures/adjoint-4.png|0.7par|||>|<label|figure: Adjoint
  functors preserve product> Illustrates how the product is preserved by
  adjoint functors <math|F\<dashv\>G>, where
  <math|F:<math-ss|C>\<rightarrow\><math-ss|D>> and
  <math|G:<math-ss|D>\<rightarrow\><math-ss|C>>. The red part indicates that
  <math|A\<times\>B> is the product of <math|A> and <math|B> in
  <math|<math-ss|D>>. The blue part indicates that
  <math|\<varepsilon\><rsub|A\<times\>B>> is universal. By putting the red
  and blue parts together, we find the relation
  <math|f=F<around*|(|f<rsup|\<sharp\>>|)>\<circ\>\<varepsilon\><rsub|A\<times\>B>>.>

  <section|Construction of Limit>

  <subsection|Category may not be complete>

  Limit is quite general in mathematics, but not everywhere. It is easy to
  construct a category that has no product. For instance, the simple category
  indicated by figure <reference|figure: Incomplete Category>.

  <big-figure|<image|figures/limit-2.png|0.3par|||>|<label|figure: Incomplete
  Category> Indicates a simple category that has no product. Indeed, only
  <math|A> and <math|C> have the potential to be a product, but if <math|A>
  were a product, there is no arrow from <math|C> to <math|A>; and if
  <math|C> were a product, there is no arrow from <math|A> to <math|C>. So,
  none of them is a product.>

  On the other side, there does be categories that has all kinds of limit,
  that is, there exists limit for every small diagram. For example, the
  <math|<math-ss|Set>> (we will prove that it has all kinds of limit). A
  category like <math|<math-ss|Set>> is called complete.

  <\definition>
    [Completeness] A locally small category <math|<math-ss|C>> is
    <with|font-series|bold|(finitely) complete> if any (finitely) small
    diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> has limit in
    <math|<math-ss|C>>.
  </definition>

  Recall that a diagram is small if its indexing category (for instance, the
  <math|<math-ss|I>> of diagram <math|D>) is small; and a diagram is finite
  if its indexing category has finite number of objects and of morphisms. A
  finite diagram is small by its own.s

  <subsection|A limit can be constructed by products and equalizers>

  Naturally, we are to wonder how we can tell a given category, such as
  <math|<math-ss|Set>>, is complete (or finitely complete). This problem can
  be ceased if there is a way of constructing any limit by some \Pbasic\Q
  limits. In this situation, if a category has these basic limits, then we
  can claim that this category is complete.

  TODO

  <\theorem>
    <label|theorem: Limit Construction by Product and Equalizer> TODO
  </theorem>

  <subsection|<math|<math-ss|Set>> is complete>

  In category <math|<math-ss|Set>>, product is Cartesian product, and
  equalizer is equalizer of sets. So, by theorem <reference|theorem: Limit
  Construction by Product and Equalizer>, we conclude that
  <math|<math-ss|Set>> is complete.

  <subsection|Limit helps generalize concepts from set theory to category
  theory>

  Mathematical concepts are built on the base of set theory, including
  concepts in analysis, topology, and even algebra. But, generalizing a
  concept in set theory by arrows, as shown by generalizing Cartesian product
  in section <reference|section: Arrows generalize concepts and theorems from
  one area to every area in mathematics>, is far from straight forward. At
  the first sight, it seems that Cartesian product of sets and its
  generalization, product of objects, have no relationship. So, you may
  wonder, how can we get some hint for generalizing Cartesian product, or
  even more complicated concepts in set theory, to its categorical version.

  We are to deal with this very problem by considering some instance. A
  proper instance is the fibered product of sets <\footnote>
    We can consider Cartesian product of sets. But, it turns out to be quite
    trivial. The fiber product, however, is non-trivial but still easy to
    compute.
  </footnote>. A <with|font-series|bold|fiber product> of two sets <math|A>
  and <math|B> is another set denoted by <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>,
  where <math|A>, and <math|B> are sets, <math|\<zeta\>:A\<rightarrow\>C> and
  <math|\<eta\>:B\<rightarrow\>C> are functions for some set <math|C>.
  Precisely,

  <\equation*>
    A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B\<assign\><around*|{|<around*|(|a,b|)>\|a\<in\>A,b\<in\>B,\<zeta\><around*|(|a|)>=\<eta\><around*|(|b|)>|}>.
  </equation*>

  Now, we are to represent this by arrows. As we have been familiar with, for
  a locally small category <math|<math-ss|C>>, the collection of morphisms,
  say <math|<math-ss|C><around*|(|X,Y|)>> for some
  <math|X,Y\<in\><math-ss|C>>, is a set. So, we can consider the fibered
  product of the sets of morphisms. Materials for constructing the
  categorical version of fibered product should be restricted, as far as
  posssible, to those appeared in the definition of fibered product, so that
  the categorical version will go back to fibered product when
  <math|<math-ss|C>> is <math|<math-ss|Set>>. So, we start constructing the
  sets of morphisms by using <math|A> and <math|B>, which is nothing but the
  <math|<math-ss|C><around*|(|A,B|)>>. This, however, will not work, since
  nothing can be done with only one set. The smallest extension is
  introducing another object <math|X\<in\><math-ss|C>>, so that we can
  consider <math|<math-ss|C><around*|(|X,A|)>> and
  <math|<math-ss|C><around*|(|X,B|)>>. Explorations of the other several
  possibilities, such as the fibered product of sets
  <math|<math-ss|C><around*|(|A,X|)>> and
  <math|<math-ss|C><around*|(|B,X|)>>, are left to reader.

  So, we replace the sets in the definition of fibered product by
  <math|A\<rightarrow\><math-ss|C><around*|(|X,A|)>>,
  <math|B\<rightarrow\><math-ss|C><around*|(|X,B|)>>, and in addition,
  <math|C\<rightarrow\><math-ss|C><around*|(|X,C|)>>. What about the
  functions <math|\<zeta\>> and <math|\<eta\>>? We have to construct a
  function <math|<wide|\<zeta\>|^>:<math-ss|C><around*|(|X,A|)>\<rightarrow\><math-ss|C><around*|(|X,C|)>>
  for replacing <math|\<zeta\>:A\<rightarrow\>C>. The only possibility that
  construct such <math|<wide|\<zeta\>|^>> using the materials used to define
  fibered product is <math|<wide|\<zeta\>|^>:X\<rightarrow\>A<above|\<rightarrow\>|\<zeta\>>C>,
  or say <math|<wide|\<zeta\>|^>\<assign\>\<zeta\><rsub|\<ast\>>>. The same,
  we replace <math|\<eta\>> by <math|\<eta\><rsub|\<ast\>>>. Thus, the
  <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B> is replaced to be

  <\equation*>
    <math-ss|C><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><math-ss|C><around*|(|X,B|)>=<around*|{|<around*|(|f,g|)>\|f:X\<rightarrow\>A,g:X\<rightarrow\>B,\<zeta\>\<circ\>f=\<eta\>\<circ\>g|}>.
  </equation*>

  The right hand side is an expression of arrows, which is what we want. It
  simply means the commutative diagram as follow.

  <big-figure|<image|figures/limit-3.png|0.3par|||>|Indicates the fibered
  product <math|<math-ss|C><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><math-ss|C><around*|(|X,B|)>>.>

  This hints for a cone with the \Pbase\Q
  <math|A<above|\<rightarrow\>|\<zeta\>>C<above|\<leftarrow\>|\<eta\>>B>, or
  with the indexing category like <math|\<bullet\>\<rightarrow\>\<bullet\>\<leftarrow\>\<bullet\>>.
  From this diagram, we build cone, and from the cone, we get the limit,
  called pullback.

  <\definition>
    [Pullback] Let <math|<math-ss|C>> a category. An object in
    <math|<math-ss|C>>, denoted by <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>,
    together with <math|A,B\<in\><math-ss|C>> and
    <math|\<zeta\>:A\<rightarrow\>C,\<eta\>:B\<rightarrow\>C> is called a
    <with|font-series|bold|pullback> if for each <math|X\<in\><math-ss|C>>,
    there exists <math|\<gamma\>:X\<rightarrow\>A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>
    such that figure <reference|figure: Pullback> commutes.
  </definition>

  <big-figure|<image|figures/limit-4.png|0.3par|||>|<label|figure: Pullback>
  Indicates the pullback <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>.
  Principaly, there should be a morphism from
  <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B> to <math|C> (and
  also from <math|X> to <math|C>). But, since the figure commutes, such a
  morphism can be represented by <math|\<zeta\>\<circ\>\<alpha\>> or by
  <math|\<eta\>\<circ\>\<beta\>>, thus is redundant and omitted.>

  We are left to check that pullback is indeed the fibered product in the
  case of <math|<math-ss|Set>>. This is left to reader. The only trick for
  proving this is using the uniqueness of representation.

  We summarize the previous steps as follow <\footnote>
    There is a theorem that relates to these steps.

    <\theorem>
      Let <math|<math-ss|C>> a locally small category. For each diagram
      <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and for each
      <math|X\<in\><math-ss|C>>, we have

      <\equation*>
        lim<rsub|<math-ss|I>><math-ss|C><around*|(|X,D<around*|(|-|)>|)>\<cong\><math-ss|C><around*|(|X,lim<rsub|<math-ss|I>>D|)>,
      </equation*>

      and (the dual)

      <\equation*>
        lim<rsub|<math-ss|I>><math-ss|C><around*|(|D<around*|(|-|)>,X|)>\<cong\><math-ss|C><around*|(|colim<rsub|<math-ss|I>>D,X|)>.
      </equation*>
    </theorem>

    But, I cannot figure out what is the explicit relationship to these
    steps.
  </footnote>.

  <\enumerate-numeric>
    <item>Write down the expression of the concept in terms of sets and
    functions.

    <item>In the expression of the concept:

    <\itemize>
      <item>replace the sets by the pattern
      <math|A\<rightarrow\><math-ss|C><around*|(|X,A|)>>, where the left hand
      side is some set <math|A> while, in the right hand side, <math|X> and
      <math|A> are object in the generic (locally small) category
      <math|<math-ss|C>>; and

      <item>replace the functions by functions between the sets of morphisms
      constructed out of those appeared in the expression of the concept.
    </itemize>

    <item>Draw the commutative diagram for the replaced expression, from
    which the \Pbase\Q of cone can be read out.

    <item>Write down the limit implied by the cone; and then prove that this
    limit will reduce to the concept in set theory when <math|<math-ss|C>> is
    <math|<math-ss|Set>>.
  </enumerate-numeric>

  This series of steps is generic. By following these steps, we can
  \Pcategorify\Q equalizer in set theory <\footnote>
    In set theory, given two sets <math|A,B> and two functions
    <math|u,v:A\<rightarrow\>B>, the equalizer of <math|u> and <math|v> is
    defined as the subset of <math|A>

    <\equation*>
      eq<around*|(|u,v|)>\<assign\><around*|{|a\|a\<in\>A,u<around*|(|a|)>=v<around*|(|a|)>|}>.
    </equation*>

    Following the same strategy, we arrive at

    <\equation*>
      eq<around*|(|u<rsub|\<ast\>>,v<rsub|\<ast\>>|)>=<around*|{|f\|f:X\<rightarrow\>A,u\<circ\>f=v\<circ\>f|}>.
    </equation*>

    Again, the right hand side is an expression of arrows, which hints for a
    cone with the \Pbase\Q <math|A<below|<above|\<rightrightarrows\>|u>|v>B>,
    or with the indexing category like <math|\<bullet\>\<rightrightarrows\>\<bullet\>>,
    as figure <reference|figure: Equalizer> shows.

    <big-figure|<image|figures/limit-5.png|0.3par|||>|<label|figure:
    Equalizer> Indicates the equalizer <math|eq<around*|(|u,v|)>>.
    Principaly, there should be a morphism from <math|eq<around*|(|u,v|)>> to
    <math|B> (and also from <math|X> to <math|B>). They are omitted for the
    same reason in figure <reference|figure: Pullback>.>

    The final step is to prove that this is indeed the equalizer in the case
    of <math|<math-ss|Set>>. Now, by following the same steps, we can
    generalize equalizer from set theory to its categorical version. Details
    are left to reader.
  </footnote>.
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|1|1>>
    <associate|auto-10|<tuple|4|3>>
    <associate|auto-11|<tuple|1.5|4>>
    <associate|auto-12|<tuple|1.6|4>>
    <associate|auto-13|<tuple|5|4>>
    <associate|auto-14|<tuple|1.7|5>>
    <associate|auto-15|<tuple|6|5>>
    <associate|auto-16|<tuple|2|6>>
    <associate|auto-17|<tuple|2.1|6>>
    <associate|auto-18|<tuple|7|6>>
    <associate|auto-19|<tuple|2.2|6>>
    <associate|auto-2|<tuple|1|1>>
    <associate|auto-20|<tuple|2.3|6>>
    <associate|auto-21|<tuple|2.4|7>>
    <associate|auto-22|<tuple|8|7>>
    <associate|auto-23|<tuple|9|8>>
    <associate|auto-24|<tuple|10|9>>
    <associate|auto-3|<tuple|1.1|1>>
    <associate|auto-4|<tuple|1.2|1>>
    <associate|auto-5|<tuple|1|2>>
    <associate|auto-6|<tuple|1.3|2>>
    <associate|auto-7|<tuple|2|2>>
    <associate|auto-8|<tuple|1.4|3>>
    <associate|auto-9|<tuple|3|3>>
    <associate|figure: Adjoint functors preserve product|<tuple|6|5>>
    <associate|figure: Colimit|<tuple|4|3>>
    <associate|figure: Cone|<tuple|1|2>>
    <associate|figure: Cone Functor|<tuple|2|2>>
    <associate|figure: Equalizer|<tuple|10|9>>
    <associate|figure: Incomplete Category|<tuple|7|6>>
    <associate|figure: Limit|<tuple|3|3>>
    <associate|figure: Product is Limit|<tuple|5|4>>
    <associate|figure: Pullback|<tuple|9|8>>
    <associate|footnote-1|<tuple|1|7>>
    <associate|footnote-2|<tuple|2|8>>
    <associate|footnote-3|<tuple|3|9>>
    <associate|footnr-1|<tuple|1|7>>
    <associate|footnr-2|<tuple|10|8>>
    <associate|footnr-3|<tuple|10|9>>
    <associate|section: Product is a limit with discrete indexing
    category|<tuple|1.6|4>>
    <associate|theorem: Limit Construction by Product and
    Equalizer|<tuple|8|6>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|figure>
      <tuple|normal|<surround|<hidden-binding|<tuple>|1>|| The left hand side
      indicates the indexing category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>.
      And the right hand side indicates the cone from
      <with|mode|<quote|math>|X> to <with|mode|<quote|math>|D>. The green
      arrows are for functor <with|mode|<quote|math>|Const<rsub|X>>, and the
      red ones for functor <with|mode|<quote|math>|D>, wherein maps on
      morphisms are not shown. As usual, identities are hidden. Since the
      <with|mode|<quote|math>|\<lambda\>> is a natural transformation, the
      right hand side commutes.>|<pageref|auto-5>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|2>|| Indicates the map
      on <with|mode|<quote|math>|f>. As an instance, the indexing category
      <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-7>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3>|| Indicates the
      limit. The dash arrow is for implication. As an instance, the indexing
      category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-9>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|4>|| Indicates the
      colimit. The dash arrow is for implication. As an instance, the
      indexing category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-10>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|5>|| Indicates that
      product is a limit. The left hand side is the indexing category. There
      is no morphism (except the hidden identities) since it is a discrete
      category. The name of the object is irrelevant, so the two objects are
      shown as dots. The right hand side is the commutative diagram for the
      definition of product. The green arrows is for the constant functor,
      and red arrows for the diagram functor.>|<pageref|auto-13>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|6>|| Illustrates how
      the product is preserved by adjoint functors
      <with|mode|<quote|math>|F\<dashv\>G>, where
      <with|mode|<quote|math>|F:<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>>\<rightarrow\><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>>
      and <with|mode|<quote|math>|G:<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>\<rightarrow\><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>>>.
      The red part indicates that <with|mode|<quote|math>|A\<times\>B> is the
      product of <with|mode|<quote|math>|A> and <with|mode|<quote|math>|B> in
      <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>>.
      The blue part indicates that <with|mode|<quote|math>|\<varepsilon\><rsub|A\<times\>B>>
      is universal. By putting the red and blue parts together, we find the
      relation <with|mode|<quote|math>|f=F<around*|(|f<rsup|\<sharp\>>|)>\<circ\>\<varepsilon\><rsub|A\<times\>B>>.>|<pageref|auto-15>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|7>|| Indicates a simple
      category that has no product. Indeed, only <with|mode|<quote|math>|A>
      and <with|mode|<quote|math>|C> have the potential to be a product, but
      if <with|mode|<quote|math>|A> were a product, there is no arrow from
      <with|mode|<quote|math>|C> to <with|mode|<quote|math>|A>; and if
      <with|mode|<quote|math>|C> were a product, there is no arrow from
      <with|mode|<quote|math>|A> to <with|mode|<quote|math>|C>. So, none of
      them is a product.>|<pageref|auto-18>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|8>||Indicates the
      fibered product <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>><around*|(|X,B|)>>.>|<pageref|auto-22>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|9>|| Indicates the
      pullback <with|mode|<quote|math>|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>.
      Principaly, there should be a morphism from
      <with|mode|<quote|math>|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>
      to <with|mode|<quote|math>|C> (and also from <with|mode|<quote|math>|X>
      to <with|mode|<quote|math>|C>). But, since the figure commutes, such a
      morphism can be represented by <with|mode|<quote|math>|\<zeta\>\<circ\>\<alpha\>>
      or by <with|mode|<quote|math>|\<eta\>\<circ\>\<beta\>>, thus is
      redundant and omitted.>|<pageref|auto-23>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|10>|| Indicates the
      equalizer <with|mode|<quote|math>|eq<around*|(|u,v|)>>. Principaly,
      there should be a morphism from <with|mode|<quote|math>|eq<around*|(|u,v|)>>
      to <with|mode|<quote|math>|B> (and also from <with|mode|<quote|math>|X>
      to <with|mode|<quote|math>|B>). They are omitted for the same reason in
      figure <reference|figure: Pullback>.>|<pageref|auto-24>>
    </associate>
    <\associate|toc>
      <vspace*|2fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-size|<quote|1.19>|1<space|2spc>Limit>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-1><vspace|1fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|1<space|2spc>Cone
      Functor and Limit> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-2><vspace|0.5fn>

      <with|par-left|<quote|1tab>|1.1<space|2spc>Diagram as a part of
      category is a functor <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-3>>

      <with|par-left|<quote|1tab>|1.2<space|2spc>Cone irradiates diagram
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-4>>

      <with|par-left|<quote|1tab>|1.3<space|2spc>Cone functor generates cones
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-6>>

      <with|par-left|<quote|1tab>|1.4<space|2spc>Limit is the representation
      of cone functor <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-8>>

      <with|par-left|<quote|1tab>|1.5<space|2spc>Infimum is a limit on poset
      <with|mode|<quote|math>|\<bbb-R\>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-11>>

      <with|par-left|<quote|1tab>|1.6<space|2spc>Product is a limit with
      discrete indexing category <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-12>>

      <with|par-left|<quote|1tab>|1.7<space|2spc>Example: product is
      preserved by adjoint functors <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-14>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|2<space|2spc>Construction
      of Limit> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-16><vspace|0.5fn>

      <with|par-left|<quote|1tab>|2.1<space|2spc>Category may not be complete
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-17>>

      <with|par-left|<quote|1tab>|2.2<space|2spc>A limit can be constructed
      by products and equalizers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-19>>

      <with|par-left|<quote|1tab>|2.3<space|2spc><with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|Set>>>>
      is complete <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-20>>

      <with|par-left|<quote|1tab>|2.4<space|2spc>Limit helps generalize
      concepts from set theory to category theory
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-21>>
    </associate>
  </collection>
</auxiliary>