<TeXmacs|2.1>

<style|generic>

<\body>
  <chapter|Limit>

  <section|Cone Functor and Limit>

  In this section, we discuss an important application of universal element
  or representation: limit. We are to show that limit is a representation of
  a functor that generates objects called cones.

  Now, the problem turns to be why cones are important. Because many
  important mathematical concepts are turn out to be cones. Remember in
  chapter <reference|chapter: Category, Functor, and Natural Transformation>,
  we have embedded some concepts in the framework of category theory, such as
  supremum and infimum, Cartesian product and adjoint union. These concepts,
  once re-written by arrows, looks weird. You may wonder where these weird
  stuffs come from. In fact, they come from limit.

  To define limit, we have to first introduce diagram, and then cone.

  <subsection|Diagram as a part of category is a functor>

  When we were discussing category, functor, and natural transformation, we
  used the metaphor that a category is a collection of diagrams. Well, what
  is a diagram precisely? Naturally, a diagram is a part of a category, say
  <math|<math-ss|C>>. By part, we indicates two aspects: the set of dots
  (objects) in a diagram is a subset of the <math|ob<rsub|<math-ss|C>>>, and
  the set of arrows (morphisms) between dots <math|X> and <math|Y> is a
  subset of the <math|<math-ss|C><around*|(|X,Y|)>>.

  Remind that, in category theory, everything shall be described by arrows.
  So, how to describe a diagram by arrows?

  Let us consider a simpler case: set theory, where a part simply means a
  finite subset. Such a subset of set <math|S> is written as
  <math|A\<assign\><around*|{|x<rsub|1>,\<ldots\>,x<rsub|n>|}>>, where
  <math|x<rsub|i>\<in\>S>. A set corresponds to a discrete category, and a
  function between sets to a functor between discrete categories. (A discrete
  category <math|<math-ss|C>> is that with
  <math|<math-ss|C><around*|(|X,X|)>=<around*|{|1<rsub|X>|}>> and
  <math|<math-ss|C><around*|(|X,Y|)>=\<varnothing\>> for each
  <math|X,Y\<in\><math-ss|C>>.) So, we are to describe <math|A> by function.
  A natural one is <math|f:I\<rightarrow\>S>, where
  <math|I\<assign\><around*|{|1,\<ldots\>,n|}>> as an \Pindexing set\Q, and
  <math|f<around*|(|i|)>\<assign\>x<rsub|i>>.

  Back to category theory, the indexing set analogies to a small category
  <math|<math-ss|I>> called indexing category, and the function <math|f>
  analogies to functor <math|F:<math-ss|I>\<rightarrow\><math-ss|C>>.
  Indexing category is used for filtering the objects and morphisms in
  <math|<math-ss|C>>, so that the image is a part of <math|<math-ss|C>>, that
  is, a diagram. We summarize the previous discussion as follow.

  <\definition>
    [Diagram] Let <math|<math-ss|I>> a small category and <math|<math-ss|C>>
    a category. An <math|<math-ss|I>>-shaped <with|font-series|bold|diagram>
    in <math|<math-ss|C>> is a functor <math|F:<math-ss|I>\<rightarrow\><math-ss|C>>.
    It is small or locally small if <math|<math-ss|C>> is small or locally
    small respectively.
  </definition>

  <subsection|Cone irradiates diagram>

  With diagram declared, we come to cone. A light cone generated by a table
  lamp irradiates the table. The table lamp is an object, and the table is a
  diagram. So, a cone irradiates a diagram.

  But, how can we describe the relation between an object and a diagram,
  which is a functor? To make this possible, we have to make the most boring
  definition so far: the constant functor. Constant functor converts an
  object to a functor.

  <\definition>
    [Constant Functor] Let <math|<math-ss|C>> and <math|<math-ss|D>>
    categories. For each <math|X\<in\><math-ss|D>>, the
    <with|font-series|bold|constant functor> of <math|X>,
    <math|Const<rsub|X>:<math-ss|C>\<rightarrow\><math-ss|D>>, is defined by

    <\itemize>
      <item>for each <math|A\<in\><math-ss|C>>,
      <math|Const<rsub|X><around*|(|A|)>=X>, and

      <item>for each <math|f:A\<rightarrow\>B>,
      <math|Const<rsub|X><around*|(|f|)>=1<rsub|X>>.
    </itemize>
  </definition>

  With this trivial definition, we can describe the relation between an
  object, or its constant functor, and a diagram.

  <\definition>
    [Cone] For each diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and
    each object <math|X\<in\><math-ss|C>>, a cone from <math|X> to <math|D>
    is a natural transformation <math|\<lambda\>:Const<rsub|X>\<rightarrow\>D>.
  </definition>

  <big-figure|<image|figures/cone.png|0.75par|||>|<label|figure: Cone> The
  left hand side indicates the indexing category <math|<math-ss|I>>. And the
  right hand side indicates the cone from <math|X> to <math|D>. The green
  arrows are for functor <math|Const<rsub|X>>, and the red ones for functor
  <math|D>, wherein maps on morphisms are not shown. As usual, identities are
  hidden. Since the <math|\<lambda\>> is a natural transformation, the right
  hand side commutes.>

  It should be noted that, in figure <reference|figure: Cone>, some morphism
  are redundant. For instance, <math|\<lambda\><rsub|A>=D<around*|(|h|)>\<circ\>\<lambda\><rsub|C>>
  and <math|\<lambda\><rsub|B>=D<around*|(|f|)>\<circ\>\<lambda\><rsub|A>=D<around*|(|f|)>\<circ\>D<around*|(|h|)>\<circ\>\<lambda\><rsub|C>>.
  So, when <math|\<lambda\><rsub|C>> has been drawn,
  <math|\<lambda\><rsub|A>> and <math|\<lambda\><rsub|B>> are omitable,
  usually absent in the diagram.

  <subsection|Cone functor generates cones>

  Notice a cone consists two parts: the diagram and the summit object. Given
  a diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and a summit object
  <math|X\<in\><math-ss|C>>, the natural transformation
  <math|\<lambda\>:Const<rsub|X>\<rightarrow\>D> is not unique. There can be
  a plenty of such natural transformations, depending on how many morphisms
  there are between objects in <math|<math-ss|C>>. We can collect these
  natural transformations together as a set, <math|Cone<around*|(|X,D|)>>.

  For the set of morphisms from <math|X> to <math|Y>,
  <math|<math-ss|C><around*|(|X,Y|)>>, we constructed a functor
  <math|<math-ss|C><around*|(|-,Y|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>,
  hom-functor. The same goes for <math|Cone<around*|(|X,D|)>>. We can
  construct a functor <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>.
  Naturally, it maps <math|X\<in\><math-ss|C>> to
  <math|Cone<around*|(|X,D|)>>, but what about the morphism, say
  <math|f:Y\<rightarrow\>X>? Consider a cone
  <math|\<lambda\>\<in\>Cone<around*|(|X,D|)>>, which is a natural
  transformation from <math|Const<rsub|X>:<math-ss|I>\<rightarrow\><math-ss|C>>
  to <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>. A component
  <math|\<lambda\><rsub|A>:X\<rightarrow\>D<around*|(|A|)>>. To construct a
  morphism <math|Y\<rightarrow\>D<around*|(|A|)>> out of
  <math|\<lambda\><rsub|A>> and <math|f>, the only possibility is
  <math|Y<above|\<rightarrow\>|f>X<above|\<rightarrow\>|\<lambda\><rsub|A>>D<around*|(|A|)>>,
  that is <math|\<lambda\><rsub|A>\<circ\>f>.

  <\definition>
    [Cone Functor] For each diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>,
    the <with|font-series|bold|cone functor>
    <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>
    is defined by

    <\itemize>
      <item>for each <math|X\<in\><math-ss|C>>, mapping <math|X> to
      <math|Cone<around*|(|X,D|)>>, the set of all cones from <math|X> to
      <math|D>, and

      <item>for each <math|f:Y\<rightarrow\>X>, mapping <math|f> to function
      <math|f<rsup|\<ast\>>:Cone<around*|(|X,D|)>\<rightarrow\>Cone<around*|(|Y,D|)>>
      defined by <math|f<rsup|\<ast\>><around*|(|\<lambda\><rsub|A>|)>=\<lambda\><rsub|A>\<circ\>f>
      for each component <math|\<lambda\><rsub|A>>. (See also figure
      <reference|figure: Cone Functor>.)
    </itemize>
  </definition>

  <big-figure|<image|figures/cone-1.png|0.55par|||>|<label|figure: Cone
  Functor> Indicates the map on <math|f>. As an instance, the indexing
  category <math|<math-ss|I>> is simply <math|A<above|\<rightarrow\>|g>B>.>

  <subsection|Limit is the representation of cone functor>

  Given diagram <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> where
  <math|<math-ss|C>> is locally small (or say, a locally small diagram), a
  cone functor <math|Cone<around*|(|-,D|)>:<math-ss|C><rsup|op>\<rightarrow\><math-ss|Set>>
  is a presheaf, thus may be representable. Theorem <reference|theorem:
  Universal Element> states that a presheaf is representable if and only if
  there is a universal element of it. Let us restate the definition of
  universal element for cone functor, which is called universal cone.

  A universal element of a cone functor <math|Cone<around*|(|-,D|)>> is a
  morphism <math|e\<in\>Cone<around*|(|lim D,D|)>> for some <math|lim
  D\<in\><math-ss|C>> such that, for each <math|X\<in\><math-ss|C>>,
  <math|Cone<around*|(|-,D|)><around*|(|e|)>:<math-ss|C><around*|(|X,lim
  D|)>\<rightarrow\>Cone<around*|(|X,D|)>> is an isomorphism. First, we have
  to evaluate <math|Cone<around*|(|-,D|)><around*|(|e<rsub|A>|)>> for each
  component <math|e<rsub|A>>. For each <math|f:X\<rightarrow\>lim D>, we have

  <\align>
    <tformat|<table|<row|<cell|>|<cell|Cone<around*|(|f,D|)><around*|(|e<rsub|A>|)>>>|<row|<cell|<around*|{|<text|definition
    of <math|Cone<around*|(|-,D|)>>>|}>=>|<cell|f<rsup|\<ast\>><around*|(|e<rsub|A>|)>>>|<row|<cell|<around*|{|<text|definition
    of <math| <around*|(|-|)><rsup|\<ast\>>>>|}>=>|<cell|e<rsub|A>\<circ\>f.>>>>
  </align>

  Next, the isomorphism <math|Cone<around*|(|-,D|)><around*|(|e|)>> is in
  fact a bijection, since both sides of the arrow are sets. As a bijection,
  it means that for each cone <math|\<lambda\>\<in\>Cone<around*|(|X,D|)>>,
  there is a unique morphism <math|f:X\<rightarrow\>lim D> such that
  <math|\<lambda\><rsub|A>=e<rsub|A>\<circ\>f> for each
  <math|A\<in\><math-ss|I>>. Finally, we put these together as follow.

  <\definition>
    [Universal Cone] For a locally small diagram
    <math|D:<math-ss|I>\<rightarrow\><math-ss|C>>, a
    <with|font-series|bold|universal cone> is a cone
    <math|e\<in\>Cone<around*|(|lim D,D|)>> for some <math|lim
    D\<in\><math-ss|C>> such that, for each <math|X\<in\><math-ss|C>> and
    each cone <math|\<lambda\>\<in\>Cone<around*|(|X,D|)>>, there is a unique
    morphism <math|f:X\<rightarrow\>lim D> such that
    <math|\<lambda\><rsub|A>=e<rsub|A>\<circ\>f> for each
    <math|A\<in\><math-ss|I>>. The <math|lim D> is called the
    <with|font-series|bold|limit> of <math|D>.
  </definition>

  <big-figure|<image|figures/limit.png|0.5par|||>|<label|figure: Limit>
  Indicates the limit. The dash arrow is for implication. As an instance, the
  indexing category <math|<math-ss|I>> is simply
  <math|A<above|\<rightarrow\>|g>B>.>

  As figure <reference|figure: Limit> indicates, the limit is the lowest
  object towards (the image of) the diagram. So, a limit is the closest
  object to the diagram, thus literally a limit.

  The dual limit is colimit, by simply exchanging domain and codomain in
  limit. As figure <reference|figure: Colimit> shows.

  \ <big-figure|<image|figures/colimit.png|0.5par|||>|<label|figure: Colimit>
  Indicates the colimit. The dash arrow is for implication. As an instance,
  the indexing category <math|<math-ss|I>> is simply
  <math|A<above|\<rightarrow\>|g>B>.>

  <subsection|Limit is unique up to isomorphism>

  Recall that the representation of a functor, if exists, is unique up to
  isomorphism. Thus, limit and colimit, which are representation of the cone
  and cocone functor respectively, are unique up to isomorphism.

  <\theorem>
    [Limit (Colimit) is Unique] The limit (colimit) of a locally small
    diagram is unique up to isomorphism.
  </theorem>

  <subsection|Infimum is a limit on poset <math|\<bbb-R\>>>

  In section <reference|section: Supremum and infimum are dual>, we roughly
  showed what infimum would be like in the framework of category theory.
  Here, we make it more precise. Recalling the definition of poset (see
  definition <reference|definition: Poset>), the field <math|\<bbb-R\>> forms
  a poset by preorder <math|\<leqslant\>>. So, it forms a poset category
  <math|<math-ss|Poset>>, with object a real number and morphism
  <math|x\<rightarrow\>y> if <math|x\<leqslant\>y>. Consider an indexing
  category <math|<math-ss|I>> as the poset
  <math|<around*|(|A,\<leqslant\>|)>> where <math|A\<subset\>\<bbb-R\>>.
  Diagram <math|D:<math-ss|I>\<rightarrow\>\<bbb-R\>> is defined by
  <math|D<around*|(|x|)>\<assign\>x> for each <math|x\<in\>\<bbb-R\>>. So,
  <math|lim D> has the property that, for each <math|x\<in\>\<bbb-R\>> and
  <math|a\<in\>A>, if <math|x\<leqslant\>D<around*|(|a|)>>, then
  <math|x\<leqslant\>lim D\<leqslant\>D<around*|(|a|)>>. This means <math|lim
  D> is the infimum of the set <math|A>. So, infimum is a universal cone, or
  a limit, on poset category.

  Since limit, or generally representation, is unique up to isomorphism,
  infimum and supremum of a subset of <math|\<bbb-R\>> is unique. (Recall
  that the only isomorphism in poset <math|\<bbb-R\>> is
  <math|x\<leqslant\>x> for each <math|x\<in\>\<bbb-R\>>.)

  The same goes for its dual, supremum. If we flip the arrows in the
  definitions of limit, we get the dual, colimit . So, directly, we find
  supremum is the colimit on <math|<math-ss|Poset>>.

  <subsection|Product is a limit with discrete indexing
  category><label|section: Product is a limit with discrete indexing
  category>

  In section <reference|section: Arrows generalize concepts and theorems from
  one area to every area in mathematics>, we showed what Cartesian product
  would be like in the framework of category theory. Let <math|<math-ss|C>> a
  category. For any <math|A,B\<in\><math-ss|C>>, the product of <math|A> and
  <math|B> is another object <math|C\<in\><math-ss|C>> together with two
  morphisms <math|\<alpha\>:C\<rightarrow\>A> and
  <math|\<beta\>:C\<rightarrow\>B> such that, for any
  <math|C<rprime|'>\<in\><math-ss|C>>, any
  <math|\<alpha\><rprime|'>:C<rprime|'>\<rightarrow\>A> and
  <math|\<beta\><rprime|'>:C<rprime|'>\<rightarrow\>B>, there exists a unique
  morphism <math|\<gamma\>:C<rprime|'>\<rightarrow\>C> so that
  <math|\<alpha\><rprime|'>=\<alpha\>\<circ\>\<gamma\>> and
  <math|\<beta\><rprime|'>=\<beta\>\<circ\>\<gamma\>>. If we convert this
  statement to commutative diagram (figure <reference|figure: Product is
  Limit>), then it is apparent that product is a limit, in which the discrete
  category with two elements is the indexing category.

  <big-figure|<image|figures/limit-1.png|0.75par|||>|<label|figure: Product
  is Limit> Indicates that product is a limit. The left hand side is the
  indexing category. There is no morphism (except the hidden identities)
  since it is a discrete category. The name of the object is irrelevant, so
  the two objects are shown as dots. The right hand side is the commutative
  diagram for the definition of product. The green arrows is for the constant
  functor, and red arrows for the diagram functor.>

  Again, since limit is unique up to isomorphism, product is unique up to
  isomorphism. Recall that we have proved the uniqueness before. Now, the
  proof is apparent on its own.

  The same goes for coproduct (definition <reference|definition: Coproduct of
  Two Objects>).

  <section|Construction of Limit>

  <subsection|Limit helps generalize concepts from set theory to category
  theory>

  Mathematical concepts are built on the base of set theory, including
  concepts in analysis, topology, and even algebra. But, generalizing a
  concept in set theory by arrows, as shown by generalizing Cartesian product
  in section <reference|section: Arrows generalize concepts and theorems from
  one area to every area in mathematics>, is far from straight forward. At
  the first sight, it seems that Cartesian product of sets and its
  generalization, product of objects, have no relationship. So, you may
  wonder, how can we get some hint for generalizing Cartesian product, or
  even more complicated concepts in set theory, to its categorical version.

  We are to deal with this very problem by considering some instances. A
  proper instance is the fibered product of sets <\footnote>
    We can consider Cartesian product of sets. But, it turns out to be quite
    trivial. The fiber product, however, is non-trivial but still easy to
    compute.
  </footnote>. A <with|font-series|bold|fiber product> of two sets <math|A>
  and <math|B> is another set denoted by <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>,
  where <math|A>, and <math|B> are sets, <math|\<zeta\>:A\<rightarrow\>C> and
  <math|\<eta\>:B\<rightarrow\>C> are functions for some set <math|C>.
  Precisely,

  <\equation*>
    A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B\<assign\><around*|{|<around*|(|a,b|)>\|a\<in\>A,b\<in\>B,\<zeta\><around*|(|a|)>=\<eta\><around*|(|b|)>|}>.
  </equation*>

  Now, we are to represent this by arrows. As we have been familiar with, for
  a locally small category <math|<math-ss|C>>, the collection of morphisms,
  say <math|<math-ss|C><around*|(|X,Y|)>> for some
  <math|X,Y\<in\><math-ss|C>>, is a set. So, we can consider the fibered
  product of the sets of morphisms. Materials for constructing the
  categorical version of fibered product should be restricted, as far as
  posssible, to those appeared in the definition of fibered product, so that
  the categorical version can go back to fibered product when
  <math|<math-ss|C>> is <math|<math-ss|Set>>. So, we start constructing the
  sets of morphisms by using <math|A> and <math|B>, which is nothing but the
  <math|<math-ss|C><around*|(|A,B|)>>. This, however, will not work, since
  nothing can be done with only one set. The smallest extension is
  considering <math|<math-ss|C><around*|(|-,A|)>> and
  <math|<math-ss|C><around*|(|-,B|)>>, which means
  <math|<math-ss|C><around*|(|X,A|)>> and <math|<math-ss|C><around*|(|X,B|)>>
  for arbitrary object <math|X\<in\><math-ss|C>>. Exploration of the other
  possibility, that is <math|<math-ss|C><around*|(|A,-|)>> and
  <math|<math-ss|C><around*|(|B,-|)>>, is left to reader.<\footnote>
    It turns out to be the dual.
  </footnote>

  So, we replace the sets in the definition of fibered product by
  <math|A\<rightarrow\><math-ss|C><around*|(|-,A|)>>,
  <math|B\<rightarrow\><math-ss|C><around*|(|-,B|)>>, and in addition,
  <math|C\<rightarrow\><math-ss|C><around*|(|-,C|)>>. What about the
  functions <math|\<zeta\>> and <math|\<eta\>>? We have to construct a
  natural transformation <math|<wide|\<zeta\>|^>:<math-ss|C><around*|(|-,A|)>\<rightarrow\><math-ss|C><around*|(|-,C|)>>
  for replacing <math|\<zeta\>:A\<rightarrow\>C>. Because of Yoneda functor,
  we have <math|<wide|\<zeta\>|^>\<assign\>\<zeta\><rsub|\<ast\>>>. The same,
  we replace <math|\<eta\>> by <math|\<eta\><rsub|\<ast\>>>. Thus, the
  <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B> is replaced to be,
  for any <math|X\<in\><math-ss|C>>,

  <\equation*>
    <math-ss|C><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><math-ss|C><around*|(|X,B|)>=<around*|{|<around*|(|f,g|)>\|f\<in\><math-ss|C><around*|(|X,A|)>,g\<in\><math-ss|C><around*|(|X,B|)>,\<zeta\><rsub|\<ast\>><around*|(|f|)>=\<eta\><rsub|\<ast\>><around*|(|g|)>|}>.
  </equation*>

  The right hand side is an expression of arrows, which is what we want. It
  simply means the commutative diagram as follow.

  <big-figure|<image|figures/limit-3.png|0.3par|||>|This
  <hlink|figure|https://q.uiver.app/#q=WzAsNCxbMSwwLCJcXGZvcmFsbCBYIl0sWzAsMSwiQSJdLFsxLDIsIkMiXSxbMiwxLCJCIl0sWzAsMSwiXFxmb3JhbGwgZiIsMV0sWzEsMiwiXFx6ZXRhIiwxXSxbMCwzLCJcXGZvcmFsbCBnIiwxXSxbMywyLCJcXGV0YSIsMV1d>
  indicates the fibered product <math|<math-ss|C><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><math-ss|C><around*|(|X,B|)>>.>

  This hints for a cone with the \Pbase\Q
  <math|A<above|\<rightarrow\>|\<zeta\>>C<above|\<leftarrow\>|\<eta\>>B>, or
  with the indexing category like <math|\<bullet\>\<rightarrow\>\<bullet\>\<leftarrow\>\<bullet\>>.
  From this diagram, we build cone, and from the cone, we get the limit,
  called pullback.

  <\definition>
    [Pullback] Let <math|<math-ss|C>> a category. An object in
    <math|<math-ss|C>>, denoted by <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>,
    together with <math|A,B\<in\><math-ss|C>> and
    <math|\<zeta\>:A\<rightarrow\>C,\<eta\>:B\<rightarrow\>C> is called a
    <with|font-series|bold|pullback> if for each <math|X\<in\><math-ss|C>>,
    there exists <math|\<gamma\>:X\<rightarrow\>A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>
    such that figure <reference|figure: Pullback> commutes.
  </definition>

  <big-figure|<image|figures/limit-4.png|0.3par|||>|<label|figure: Pullback>
  Indicates the pullback <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>.
  Principaly, there should be a morphism from
  <math|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B> to <math|C> (and
  also from <math|X> to <math|C>). But, since the figure commutes, such a
  morphism can be represented by <math|\<zeta\>\<circ\>\<alpha\>> or by
  <math|\<eta\>\<circ\>\<beta\>>, thus is redundant and omitted.>

  We are left to check that pullback is indeed the fibered product in the
  case of <math|<math-ss|Set>>. This is left to reader. The only trick for
  proving this is using the uniqueness of representation.

  We summarize the previous steps as follow <\footnote>
    There is a theorem that relates to these steps.

    <\theorem>
      Let <math|<math-ss|C>> a locally small category. For each diagram
      <math|D:<math-ss|I>\<rightarrow\><math-ss|C>> and for each
      <math|X\<in\><math-ss|C>>, we have

      <\equation*>
        lim<math-ss|C><around*|(|X,D<around*|(|-|)>|)>\<cong\><math-ss|C><around*|(|X,lim
        D|)>,
      </equation*>

      and (the dual)

      <\equation*>
        lim<math-ss|C><around*|(|D<around*|(|-|)>,X|)>\<cong\><math-ss|C><around*|(|colim
        D,X|)>.
      </equation*>
    </theorem>

    But, I cannot figure out what is the explicit relationship to these
    steps.
  </footnote>.

  <\enumerate-numeric>
    <item>Write down the expression of the concept in terms of sets and
    functions.

    <item>In the expression of the concept:

    <\itemize>
      <item>replace the sets by the pattern
      <math|A\<rightarrow\><math-ss|C><around*|(|-,A|)>>, where the left hand
      side is some set <math|A> while, in the right hand side, <math|A> is an
      generic object in the locally small category <math|<math-ss|C>>; and

      <item>replace the functions by Yoneda functor.
    </itemize>

    <item>Draw the commutative diagram for the replaced expression, from
    which the \Pbase\Q of cone can be read out.

    <item>Write down the limit implied by the cone; and then check that this
    limit will reduce to the concept in set theory when <math|<math-ss|C>> is
    <math|<math-ss|Set>>.
  </enumerate-numeric>

  This series of steps is generic. By following these steps, we can
  \Pcategorify\Q equalizer in set theory <\footnote>
    In set theory, given two sets <math|A,B> and two functions
    <math|u,v:A\<rightarrow\>B>, the equalizer of <math|u> and <math|v> is
    defined as the subset of <math|A>

    <\equation*>
      eq<around*|(|u,v|)>\<assign\><around*|{|a\|a\<in\>A,u<around*|(|a|)>=v<around*|(|a|)>|}>.
    </equation*>

    Following the same strategy, we arrive at

    <\equation*>
      eq<around*|(|u<rsub|\<ast\>>,v<rsub|\<ast\>>|)>=<around*|{|f\|f\<in\><math-ss|C><around*|(|X,A|)>,u\<circ\>f=v\<circ\>f|}>.
    </equation*>

    Again, the right hand side is an expression of arrows, which hints for a
    cone with the \Pbase\Q <math|A<below|<above|\<rightrightarrows\>|u>|v>B>,
    or with the indexing category like <math|\<bullet\>\<rightrightarrows\>\<bullet\>>,
    as figure <reference|figure: Equalizer> shows.

    <big-figure|<image|figures/limit-5.png|0.3par|||>|<label|figure:
    Equalizer> Indicates the equalizer <math|eq<around*|(|u,v|)>>.
    Principaly, there should be a morphism from <math|eq<around*|(|u,v|)>> to
    <math|B> (and also from <math|X> to <math|B>). They are omitted for the
    same reason in figure <reference|figure: Pullback>.>

    The final step is to prove that this is indeed the equalizer in the case
    of <math|<math-ss|Set>>. Now, by following the same steps, we can
    generalize equalizer from set theory to its categorical version. Details
    are left to reader.
  </footnote>.
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|1|1>>
    <associate|auto-10|<tuple|4|3>>
    <associate|auto-11|<tuple|1.5|4>>
    <associate|auto-12|<tuple|1.6|4>>
    <associate|auto-13|<tuple|1.7|4>>
    <associate|auto-14|<tuple|5|4>>
    <associate|auto-15|<tuple|2|5>>
    <associate|auto-16|<tuple|2.1|5>>
    <associate|auto-17|<tuple|6|5>>
    <associate|auto-18|<tuple|7|5>>
    <associate|auto-19|<tuple|8|5>>
    <associate|auto-2|<tuple|1|1>>
    <associate|auto-20|<tuple|8|6>>
    <associate|auto-21|<tuple|9|6>>
    <associate|auto-22|<tuple|9|6>>
    <associate|auto-23|<tuple|9|7>>
    <associate|auto-24|<tuple|9|7>>
    <associate|auto-25|<tuple|10|8>>
    <associate|auto-3|<tuple|1.1|1>>
    <associate|auto-4|<tuple|1.2|1>>
    <associate|auto-5|<tuple|1|2>>
    <associate|auto-6|<tuple|1.3|2>>
    <associate|auto-7|<tuple|2|2>>
    <associate|auto-8|<tuple|1.4|3>>
    <associate|auto-9|<tuple|3|3>>
    <associate|figure: Adjoint functors preserve product|<tuple|6|5>>
    <associate|figure: Colimit|<tuple|4|3>>
    <associate|figure: Cone|<tuple|1|2>>
    <associate|figure: Cone Functor|<tuple|2|2>>
    <associate|figure: Equalizer|<tuple|8|8>>
    <associate|figure: Incomplete Category|<tuple|6|5>>
    <associate|figure: Limit|<tuple|3|3>>
    <associate|figure: Product is Limit|<tuple|5|4>>
    <associate|figure: Pullback|<tuple|7|7>>
    <associate|footnote-1|<tuple|1|6>>
    <associate|footnote-2|<tuple|2|8>>
    <associate|footnote-3|<tuple|3|8>>
    <associate|footnote-4|<tuple|4|?>>
    <associate|footnr-1|<tuple|1|6>>
    <associate|footnr-2|<tuple|2|8>>
    <associate|footnr-3|<tuple|8|8>>
    <associate|footnr-4|<tuple|8|?>>
    <associate|section: Product is a limit with discrete indexing
    category|<tuple|1.7|4>>
    <associate|theorem: Limit Construction by Product and
    Equalizer|<tuple|7|6>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|figure>
      <tuple|normal|<surround|<hidden-binding|<tuple>|1>|| The left hand side
      indicates the indexing category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>.
      And the right hand side indicates the cone from
      <with|mode|<quote|math>|X> to <with|mode|<quote|math>|D>. The green
      arrows are for functor <with|mode|<quote|math>|Const<rsub|X>>, and the
      red ones for functor <with|mode|<quote|math>|D>, wherein maps on
      morphisms are not shown. As usual, identities are hidden. Since the
      <with|mode|<quote|math>|\<lambda\>> is a natural transformation, the
      right hand side commutes.>|<pageref|auto-5>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|2>|| Indicates the map
      on <with|mode|<quote|math>|f>. As an instance, the indexing category
      <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-7>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|3>|| Indicates the
      limit. The dash arrow is for implication. As an instance, the indexing
      category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-9>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|4>|| Indicates the
      colimit. The dash arrow is for implication. As an instance, the
      indexing category <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|I>>>>
      is simply <with|mode|<quote|math>|A<above|\<rightarrow\>|g>B>.>|<pageref|auto-10>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|5>|| Indicates that
      product is a limit. The left hand side is the indexing category. There
      is no morphism (except the hidden identities) since it is a discrete
      category. The name of the object is irrelevant, so the two objects are
      shown as dots. The right hand side is the commutative diagram for the
      definition of product. The green arrows is for the constant functor,
      and red arrows for the diagram functor.>|<pageref|auto-14>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|6>|| Illustrates how
      the product is preserved by adjoint functors
      <with|mode|<quote|math>|F\<dashv\>G>, where
      <with|mode|<quote|math>|F:<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>>\<rightarrow\><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>>
      and <with|mode|<quote|math>|G:<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>\<rightarrow\><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>>>.
      The red part indicates that <with|mode|<quote|math>|A\<times\>B> is the
      product of <with|mode|<quote|math>|A> and <with|mode|<quote|math>|B> in
      <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|D>>>>.
      The blue part indicates that <with|mode|<quote|math>|\<varepsilon\><rsub|A\<times\>B>>
      is universal. By putting the red and blue parts together, we find the
      relation <with|mode|<quote|math>|f=F<around*|(|f<rsup|\<sharp\>>|)>\<circ\>\<varepsilon\><rsub|A\<times\>B>>.>|<pageref|auto-16>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|7>|| Indicates a simple
      category that has no product. Indeed, only <with|mode|<quote|math>|A>
      and <with|mode|<quote|math>|C> have the potential to be a product, but
      if <with|mode|<quote|math>|A> were a product, there is no arrow from
      <with|mode|<quote|math>|C> to <with|mode|<quote|math>|A>; and if
      <with|mode|<quote|math>|C> were a product, there is no arrow from
      <with|mode|<quote|math>|A> to <with|mode|<quote|math>|C>. So, none of
      them is a product.>|<pageref|auto-19>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|8>||Indicates the
      fibered product <with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>><around*|(|X,A|)>\<times\><rsub|<around*|(|\<zeta\><rsub|\<ast\>>,\<eta\><rsub|\<ast\>>|)>><rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|C>>><around*|(|X,B|)>>.>|<pageref|auto-23>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|9>|| Indicates the
      pullback <with|mode|<quote|math>|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>.
      Principaly, there should be a morphism from
      <with|mode|<quote|math>|A\<times\><rsub|<around*|(|\<zeta\>,\<eta\>|)>>B>
      to <with|mode|<quote|math>|C> (and also from <with|mode|<quote|math>|X>
      to <with|mode|<quote|math>|C>). But, since the figure commutes, such a
      morphism can be represented by <with|mode|<quote|math>|\<zeta\>\<circ\>\<alpha\>>
      or by <with|mode|<quote|math>|\<eta\>\<circ\>\<beta\>>, thus is
      redundant and omitted.>|<pageref|auto-24>>

      <tuple|normal|<surround|<hidden-binding|<tuple>|10>|| Indicates the
      equalizer <with|mode|<quote|math>|eq<around*|(|u,v|)>>. Principaly,
      there should be a morphism from <with|mode|<quote|math>|eq<around*|(|u,v|)>>
      to <with|mode|<quote|math>|B> (and also from <with|mode|<quote|math>|X>
      to <with|mode|<quote|math>|B>). They are omitted for the same reason in
      figure <reference|figure: Pullback>.>|<pageref|auto-25>>
    </associate>
    <\associate|toc>
      <vspace*|2fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|font-size|<quote|1.19>|1<space|2spc>Limit>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-1><vspace|1fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|1<space|2spc>Cone
      Functor and Limit> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-2><vspace|0.5fn>

      <with|par-left|<quote|1tab>|1.1<space|2spc>Diagram as a part of
      category is a functor <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-3>>

      <with|par-left|<quote|1tab>|1.2<space|2spc>Cone irradiates diagram
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-4>>

      <with|par-left|<quote|1tab>|1.3<space|2spc>Cone functor generates cones
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-6>>

      <with|par-left|<quote|1tab>|1.4<space|2spc>Limit is the representation
      of cone functor <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-8>>

      <with|par-left|<quote|1tab>|1.5<space|2spc>Limit is unique up to
      isomorphism <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-11>>

      <with|par-left|<quote|1tab>|1.6<space|2spc>Infimum is a limit on poset
      <with|mode|<quote|math>|\<bbb-R\>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-12>>

      <with|par-left|<quote|1tab>|1.7<space|2spc>Product is a limit with
      discrete indexing category <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-13>>

      <with|par-left|<quote|1tab>|1.8<space|2spc>Example: product is
      preserved by adjoint functors <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-15>>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|2<space|2spc>Construction
      of Limit> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-17><vspace|0.5fn>

      <with|par-left|<quote|1tab>|2.1<space|2spc>Category may not be complete
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-18>>

      <with|par-left|<quote|1tab>|2.2<space|2spc>A limit can be constructed
      by products and equalizers <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-20>>

      <with|par-left|<quote|1tab>|2.3<space|2spc><with|mode|<quote|math>|<rigid|<with|mode|<quote|text>|<with|font-family|<quote|ss>|font-shape|<quote|right>|Set>>>>
      is complete <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-21>>

      <with|par-left|<quote|1tab>|2.4<space|2spc>Limit helps generalize
      concepts from set theory to category theory
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-22>>
    </associate>
  </collection>
</auxiliary>